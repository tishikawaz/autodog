"""The `PyCode` class provides methods to manipulate Python code stored in
a file. It can parse the code into an abstract syntax tree, convert the
tree back to a string, write the code to a file, and insert
documentation strings generated by a `DocEngine` object into the code.
The module also includes helper functions `offset_lines` and
`insert_docstring`. The `offset_lines` function takes in a string `doc`
and an integer `level` as input and returns a modified string with each
line of the input string indented by `level` spaces, except for the
first and last lines. The `insert_docstring` function adds a docstring
to the given AST node. The node can be of type `ast.AsyncFunctionDef`,
`ast.FunctionDef`, `ast.ClassDef`, or `ast.Module`. If the node is not
of any of these types, the function returns without doing anything. If
the node already has a docstring, the function replaces it with the new
docstring. If the node does not have a docstring, the function adds the
new docstring as the first statement in the node's body. The function
also adjusts the indentation of the docstring to match the indentation
of the node's body.
"""
import ast
import os
from functools import singledispatchmethod
from typing import Optional

from autodog.engine.base import Engine
from autodog.docmodel.base import DocModel
from autodog.utils.progress import progress_bar_nothing


class PyCode:
    """This is a Python class that provides methods to manipulate Python code.
    The class takes a file path as input and parses the code using the `ast`
    module. It provides methods to convert the parsed code back to a string,
    write the code to a file, and insert documentation strings into the code
    using a `DocEngine` object.

    Methods
    -------
    - `__init__(self, filepath: str) -> None`: Initialize a new instance of
    the class with the given file path. The file is opened in read mode and
    its contents are parsed using the `ast` module. The resulting abstract
    syntax tree is stored in the 'tree' attribute of the instance.
    - `to_str(self) -> str`: Converts an abstract syntax tree (AST) to a
    string representation.
    - `write(self, filepath='') -> None`: The `write` method writes the
    contents of the current object to a file specified by the `filepath`
    parameter. If `filepath` is an empty string, the method writes to the
    original file. If `filepath` is not empty, the method writes to the file
    specified by `filepath`. The method returns `None`.
    - `insert_docs(self, engine: any, overwrite=False,
    progress_bar=progress_bar_nothing, **kwargs) -> None`: The `insert_docs`
    function inserts documentation strings for all nodes in the abstract
    syntax tree of the current object into the specified database engine. It
    takes two arguments: `engine`, which is the database engine to insert
    the documentation strings into, and `overwrite` (optional), which is a
    boolean value that determines whether to overwrite existing
    documentation strings in the database. The function returns `None`.
    Private Methods:
    - `_write_to_original(self) -> None`: The `_write_to_original` method
    writes the string representation of the object to the file specified by
    `self.filepath`. It takes no arguments and returns nothing (`None`).
    - `_insert_docs(self, node: any, engine: DocEngine, overwrite: bool) ->
    None`: The `_insert_docs` function is a decorated method that inserts
    documentation for a given node using the specified documentation engine.
    It takes three arguments: `node`, which is the node for which
    documentation needs to be inserted, `engine`, which is the documentation
    engine to be used for inserting documentation, and `overwrite`, which is
    a flag indicating whether to overwrite existing documentation. The
    function returns `None`.
    """

    def __init__(self, filepath: str) -> None:
        """Initialize a new instance of the class with the given file path. The
        file is opened in read mode and its contents are parsed using the ast
        module. The resulting abstract syntax tree is stored in the 'tree'
        attribute of the instance.
        :param filepath: A string representing the path to the file to be
        parsed.
        :type filepath: str
        :return: None
        :rtype: None
        The docstring provides a brief description of the function, its
        parameters, and its return value. It also explains what the function
        does and how it works.
        """
        self.filepath = filepath
        with open(filepath) as f:
            self.tree = ast.parse(f.read())

    def to_str(self) -> str:
        """Converts an abstract syntax tree (AST) to a string representation.

        Args:
        ----
            self (AST): The AST object to be converted.

        Returns:
        -------
            str: A string representation of the AST.

        Raises:
        ------
            None.
        """
        return ast.unparse(self.tree)

    def write(self, filepath:Optional[str]=None) -> None:
        """Writes the contents of the current object to a file.

        Args:
        ----
            filepath (str, optional): The path of the file to write to. If not
            provided, the method writes to the original file.

        Returns:
        -------
            None: This method does not return any value.

        Raises:
        ------
            FileNotFoundError: If the specified `filepath` does not exist.

        Notes:
        -----
            - If `filepath` is an empty string, the method writes to the
            original file.
            - If `filepath` is not empty, the method writes to the file
            specified by `filepath`.
        """
        if filepath is None:
            filepath = self.filepath
        with open(filepath, "w") as f:
            f.write(self.to_str())
            return None

    def insert_docs(
        self, engine:any, doc_model:DocModel, overwrite=False, progress_bar=progress_bar_nothing, **kwargs,
    ) -> None:
        """Inserts documentation strings for all nodes in the abstract syntax tree
        of the current object into the specified database engine.

        Args:
        ----
            engine (any): The database engine to insert the documentation
            strings into.
            overwrite (bool, optional): Determines whether to overwrite existing
            documentation strings in the database. Defaults to False.
            progress_bar (callable, optional): Progress bar function. Defaults
            to progress_bar_nothing.
            **kwargs: Additional keyword arguments to be passed to the progress
            bar function.

        Returns:
        -------
            None
        Description:
            The `insert_docs` function iterates over all nodes in the abstract
            syntax tree using the `ast.walk` method and calls the `_insert_docs`
            method for each node, passing in the node, the database engine, and
            the `overwrite` flag.
        """
        for node in progress_bar(ast.walk(self.tree), **kwargs):
            self._insert_docs(node, engine, doc_model, overwrite)

    @singledispatchmethod
    def _insert_docs(self, node:any, engine:Engine, doc_model:DocModel, overwrite:bool) -> None:
        """The `_insert_docs` function is a decorated method that inserts
        documentation for a given node using the specified documentation engine.

        Args:
        ----
            node (any): The node for which documentation needs to be inserted.
            engine (DocEngine): The documentation engine to be used for
            inserting documentation.
            overwrite (bool): A flag indicating whether to overwrite existing
            documentation.

        Returns:
        -------
            None.
        """
        pass

    @_insert_docs.register
    def _(self, node:ast.Module, engine:Engine, doc_model:DocModel, overwrite:bool) -> None:
        """Registers a function `_` to insert documentation into a given
        `ast.Module` node using a specified `DocEngine`.
        If the `node` already has a docstring or `overwrite` is set to `True`,
        the function generates a new documentation using the `DocEngine` and
        inserts it into the `node`.

        Args:
        ----
            node (ast.Module): The `ast.Module` node to insert documentation
            into.
            engine (DocEngine): The `DocEngine` to use for generating
            documentation.
            overwrite (bool): A flag indicating whether to overwrite an existing
            docstring in the `node`.

        Returns:
        -------
            None.
        """
        if ast.get_docstring(node) is None or overwrite:
            doc = engine.generate_doc(
                ast.unparse(node),
                lang="Python",
                statement_kind="module",
                doc_format=doc_model.module_format()
            )
            insert_docstring(node, doc)

    @_insert_docs.register
    def _(self, node:ast.FunctionDef, engine:Engine, doc_model:DocModel, overwrite:bool) -> None:
        """This function is a decorator that registers a function to insert
        docstrings into Python code.

        Args:
        ----
            node (ast.FunctionDef): An AST node representing a function
            definition.
            engine (DocEngine): A `DocEngine` object used to generate the
            docstring.
            overwrite (bool): A boolean indicating whether to overwrite an
            existing docstring.

        Returns:
        -------
            None
        Description:
            If the `node` does not have a docstring or `overwrite` is `True`,
            the function generates a docstring using the `DocEngine` object and
            inserts it into the `node` using the `insert_docstring` function.
            The generated docstring is based on the unparsed source code of the
            `node` and the language is set to Python.
        """
        if ast.get_docstring(node) is None or overwrite:
            doc = engine.generate_doc(
                ast.unparse(node),
                lang="Python",
                statement_kind="function",
                doc_format=doc_model.function_format()
            )
            insert_docstring(node, doc)

    @_insert_docs.register
    def _(self, node:ast.AsyncFunctionDef, engine:Engine, doc_model:DocModel, overwrite:bool) -> None:
        """Registers a function `_insert_docs` that takes in a node of type
        `ast.AsyncFunctionDef`, a `DocEngine` object, and a boolean `overwrite`.
        If the node already has a docstring or `overwrite` is True, the function
        generates a new docstring using the `generate_func_doc` method of the
        `DocEngine` object and inserts it into the node using the
        `insert_docstring` function. The function does not return anything.
        """
        if ast.get_docstring(node) is None or overwrite:
            doc = engine.generate_doc(
                ast.unparse(node),
                lang="Python",
                statement_kind="async function",
                doc_format=doc_model.function_format()
            )
            insert_docstring(node, doc)

    @_insert_docs.register
    def _(self, node:ast.ClassDef, engine:Engine, doc_model:DocModel, overwrite:bool) -> None:
        """This function is a decorator that registers a function to insert a
        docstring for a Python class definition.

        Args:
        ----
            node (ast.ClassDef): An AST (Abstract Syntax Tree) `ClassDef` node
            representing the class definition.
            engine (DocEngine): A `DocEngine` object used to generate the class
            documentation.
            overwrite (bool): A boolean value indicating whether to overwrite an
            existing docstring or not.

        Returns:
        -------
            None
        Description:
            If the class definition already has a docstring or the `overwrite`
            parameter is `True`, the function generates a new docstring using
            the `DocEngine` object and inserts it into the class definition
            using the `insert_docstring` function. The function does not return
            anything.
        """
        if ast.get_docstring(node) is None or overwrite:
            doc = engine.generate_doc(
                ast.unparse(node),
                lang="Python",
                statement_kind="class",
                doc_format=doc_model.class_format()
            )
            insert_docstring(node, doc)


def offset_lines(doc:str, level:int) -> str:
    """This function takes in a string `doc` and an integer `level` as input
    and returns a modified string with each line of the input string
    indented by `level` spaces, except for the first and last lines. The
    `doc` parameter is a string containing the document to be indented,
    while the `level` parameter is an integer representing the number of
    spaces to indent each line. The function returns a modified string with
    each line of the input string indented by `level` spaces, except for the
    first and last lines. The return type is a string.
    """
    lines = doc.splitlines()
    return (
        lines[0]
        + "".join(
            [os.linesep + " " * level + line if line else "" for line in lines[1:]],
        )
        + os.linesep
        + " " * level
    )


def insert_docstring(node:any, doc:str) -> None:
    """This function adds a docstring to the given AST node. The node can be of
    type ast.AsyncFunctionDef, ast.FunctionDef, ast.ClassDef, or ast.Module.
    If the node is not of any of these types, the function returns without
    doing anything. If the node already has a docstring, the function
    replaces it with the new docstring. If the node does not have a
    docstring, the function adds the new docstring as the first statement in
    the node's body. The function also adjusts the indentation of the
    docstring to match the indentation of the node's body.
    """
    if not isinstance(
        node, (ast.AsyncFunctionDef, ast.FunctionDef, ast.ClassDef, ast.Module)
    ):
        return
    if not (node.body and isinstance(node.body[0], ast.Expr)):
        offset = node.body[0].col_offset
        node.body.insert(
            0,
            ast.Expr(
                value=ast.Constant(offset_lines(doc, offset)),
                col_offset=offset,
                end_col_offset=offset,
            ),
        )
        return
    node_head = node.body[0].value
    if isinstance(node_head, ast.Str):
        node_head.s = offset_lines(doc, node_head.col_offset)
        return
    elif isinstance(node_head, ast.Constant) and isinstance(node_head.value, str):
        node_head.value = offset_lines(doc, node_head.col_offset)
        return
